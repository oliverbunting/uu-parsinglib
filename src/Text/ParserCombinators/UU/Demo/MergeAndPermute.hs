{-# LANGUAGE NoMonomorphismRestriction,
             RankNTypes,
             FlexibleContexts,
             CPP  #-}
#define DEMO(p,i) demo "p" i p
#define DEMOG(p,i) demo "p" i (mkParserM (p))
module Text.ParserCombinators.UU.Demo.MergeAndPermute where

import Text.ParserCombinators.UU
import Text.ParserCombinators.UU.MergeAndPermute
import Text.ParserCombinators.UU.BasicInstances
import Text.ParserCombinators.UU.Utils
import Text.ParserCombinators.UU.Demo.Examples
import qualified Data.ListLike as LL 

type Grammar a = (IsLocationUpdatedBy loc Char, LL.ListLike state Char) => Gram (P (Str Char state loc)) a

pA, pB, pC:: Grammar String
pA   = mkGram pa
pB   = mkGram pb
pC   = mkGram (lift <$> pSym 'c')


pNat ::  Grammar Int
pNat = mkGram pNatural


pDigit' = mkGram pDigit

-- | `two` recognises two instance of p as part of the input sequence
two :: Applicative f => f [a] -> f [a]
two p = (++) <$> p <*> p
-- | `three` recognises two instance of p as part of the input sequence
three :: Applicative f => f a-> f (a,a,a)
three p = (,,) <$> p <*> p <*> p



-- | `pABC` minimcs a series of events (here an @a@, a @b@ and a @c@), which belong to the same transaction. 
--   The transaction is identified by a digit: hence a full transaction is a string like \"a5b5c5\". 
--   The third element in the body of `show_demos` below shows how the different transactions can be recovered from  a log-file which contains all events generated by a collection
--   of concurrently running transactions.
pABC :: Grammar String
pABC = (\ a d -> d:a) <$> pA <*> (pDigit' >>= \d ->  pB *> mkGram (pSym d) *> pC *> mkGram (pSym d))

-- | By running the function `show-demos` you will see a demonsration of the various parsers.
show_demos :: IO ()
show_demos = do DEMOG (((,,) <$> two pA <||> three pB <||> pBetween 2 4 pC ), "cababbcccc")
                DEMO  ((amb (mkParserM ((,) <$> pmMany ((,) <$>  pA <*> pC) <||> pmMany pB)))  , "aabbcaabbccc")
                DEMOG ((pmMany(pABC))                                                          , "a2a1b1b2c2a3b3c1c3")
                DEMOG (((,)    <$> pBetween 2 3 pA <||> pBetween 1 2 pB)                       , "abba")  
                DEMOG (((,)    <$> pBetween 2 3 pA <||> pBetween 1 2 pB)                       , "bba")
                DEMO ((amb (mkParserM( ((,)    <$> pBetween 2 3 pA <||> pBetween 1 2 pA))))    , "aaa")
                putStr "The 'a' at the right hand side can b any of the three 'a'-s in the input\n"
                DEMOG (((,)    <$> pAtLeast 3 pA <||> pAtMost 3 pB)                            , "aabbbb")  
                DEMOG (((,)    <$> pSome pA <||> pMany pB)                                     , "abba")       
                DEMOG (((,)    <$> pSome pA <||> pMany pB)                                     , "abba")           
                DEMOG (((,)    <$> pSome pA <||> pMany pB)                                     , "")         
                DEMOG (((,)    <$> pMany pB <||> pSome pC)                                     , "bcbc")          
                DEMOG (((,)    <$> pSome pB <||> pMany pC)                                     , "bcbc")
                DEMOG (((,,,)   <$> pSome pA <||> pMany pB <||> pC <||> (pNat `opt` 5) )       , "bcab45" )
                DEMOG (((,)    <$> pMany (pA <|> pB) <||> pSome  pNat)                         , "1ab12aab14")
                DEMOG (( (,)   <$> ((++) <$> pMany pA <||> pMany pB) <||> pC)                  , "abcaaab")
                DEMO  ((pc `mkParserS` ((,) <$> pMany pA <||> pMany pB))                       , "acbcacb")

-- >>> show 5
{-
-}


